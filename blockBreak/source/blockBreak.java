/* autogenerated by Processing revision 1283 on 2022-07-12 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class blockBreak extends PApplet {

int nowScene = 0;

float sleepTime = 0;
final float MaxSleepTime = 50;

final int charSize = 80;

ArrayList<Ball> balls;
int score = 0;
int nowMaxBlocks = 0;
int flame = 0;

int level = 1;
final int MaxLevel = 3;

final float Width = 1280.0f, Height = 720.0f;

 public void setup(){
  /* size commented out by preprocessor */;
  textSize(charSize);
  
  initBallX = width/2;
  initBallY = height/2;
  
  initBarX = width/2;
  initBarY = height;
  
  balls = new ArrayList<Ball>();
  
  setColors();
}


 public void draw(){
  background(255,255,255);
  switch(nowScene){
    case 0 : drawStart(); break;
    case 1 : drawGame(); break;
    case 2 : drawEnd(); break;
  }
}

 public void drawStart(){
  fill(0);
  textAlign(CENTER, CENTER);
  text("brick breaker(2210154) \n Please Press any key", width/2, height/2);
  
  if(keyPressed){
    initGame();
    nowScene = 1; 
  }
}

int baseTime = millis();
int endTime = 0;

 public void drawGame(){
  
  fill(0);
  textAlign(LEFT, BOTTOM);
  text("score:" + str(score) + ":: time:" +
    str((millis() - baseTime)/1000)+"s",
      0.0f,height);
  
  fill(255,255,255);
  
  if(gameUpdate()){
    nowScene = 2;
    balls.clear();
    sleepTime = 0;
    endTime = millis();
  }
  
}


 public void drawEnd(){
  fill(0);
  textAlign(CENTER, CENTER);
  if(cntDelBlocks == nowMaxBlocks)text("Clear Time: " + str((endTime - baseTime)/1000.0f) + "s", width/2, height/2);
  else text("You break " + str(score) + " blocks.", width/2, height/2);
  text("Please Press any key & restart!", width/2, height/2 + charSize);
  sleepTime += 1;
  if(sleepTime >= MaxSleepTime){
    if(keyPressed){
      if(cntDelBlocks == nowMaxBlocks && level < MaxLevel)level += 1;
      initGame();
      nowScene = 1;
    }
  }
  
}

 public void initGame(){
  setBlocks();
  balls.add(new Ball(initBallX, initBallY, 
  initBallVX, initBallVY, initBallRadius));
  bar.x = initBarX;
  bar.y = initBarY;
  score = 0;
  cntDelBlocks = 0;
  baseTime = millis();
  flame = 0;
  movePix = 0;
  isReach = false;
}
float initBallX;
float initBallY;
float initBallVX = 0.0f;
float initBallVY = 10.0f;
float initBallRadius = 10.0f;

final int SetHitWallFlame = 10;
final int SetHitBarFlame = 5;
final float MaxLife = 5000;

float normalVecX, normalVecY, tmpA,normSQ,norm;

class Ball{
  float x, y,vX,vY, radius;
  int hitWallFlame,hitBarFlame;
  float life;
  
  Ball(float tmpBallX,float tmpBallY,
    float tmpBallVX,float tmpBallVY, float tmpBallRadius){
    this.x = tmpBallX;
    this.y = tmpBallY;
    this.vX = tmpBallVX;
    this.vY = tmpBallVY;
    this.radius = tmpBallRadius;
    this.hitWallFlame = SetHitWallFlame;
    this.hitBarFlame = SetHitBarFlame;
    this.life = MaxLife;
  }
  
   public void move(){
    x += vX;
    y += vY;
    life -= abs(vX);
  }
  
   public Boolean collisionWall(){
    Boolean isCollision = false;
    if(hitWallFlame != 0){
      hitWallFlame--;
      return false;
    }
    
    if(x > width - radius || x < radius) {
      vX = -vX;
      hitWallFlame = SetHitWallFlame;
      isCollision = true;
    }
    if(y < 0){
      vY = -vY;;
    }
    return isCollision;
  }
  
   public void collisionBar(){
    if(hitBarFlame != 0){
      hitBarFlame--;
      return;
    }
    normalVecX = bar.x - x;
    normalVecY = bar.y - y;
    normSQ = sq(normalVecX) + sq(normalVecY);
    if(normSQ < cirLenSQ && y < bar.y && normSQ > barRadius){
      norm = sqrt(normSQ);
      normalVecX /= norm;
      normalVecY /= norm;
      tmpA = -(normalVecX*vX + normalVecY*vY)*2;
      vX = vX + tmpA*normalVecX;
      vY = vY + tmpA*normalVecY;
      hitBarFlame = SetHitBarFlame;
      
      x -= radius*normalVecX;
      y -= radius*normalVecY;
    }
  }
  
   public int collisionBlock(){
    int areaIndex = PApplet.parseInt((x - BlockGap)/ AreaWidth) + 
      PApplet.parseInt((y - BlockGap - movePix)/ AreaHeight) * BlockRow;
    if(areaIndex >= blocks.length || areaIndex < 0)return -1;
    if(!blocks[areaIndex].hitFlag){
      float tmpX = x - blocks[areaIndex].x - vX;
      if(tmpX <= 0 || tmpX >= AreaWidth)vX = -vX;
      else vY = -vY;
      return areaIndex;
    }
    return -1;
  }
  
   public void display(){
    fill(255 - life*255/MaxLife);
    ellipse(x, y, radius*2, radius*2);
  }
  
   public Boolean isRemove(){
    return y > height || life <= 0 || x < 0 || x > width;
  }
}
float initBarX = width;
float initBarY = height;
float initBarVX = 15.0f;
float initBarVY = 0.0f;
float initBarWidth = 200.0f;
float initBarHeight = 50.0f;

final float barRadius = 100.0f;
final float twoBarRadius = barRadius*2;

Bar bar = new Bar(initBarX,initBarY, initBarVX, initBarVY, initBarWidth, initBarHeight);

class Bar{
  float x, y, vX, vY,
      _width, _height;
  Bar(float tmpBarX, float tmpBarY, float tmpBarVX, float tmpBarVY,
      float tmpBarWidth, float tmpBarHeight){
        this.x = tmpBarX;
        this.y = tmpBarY;
        this.vX = tmpBarVX;
        this.vY = tmpBarVY;
        this._width = tmpBarWidth;
        this._height = tmpBarHeight;
  }
  
   public void move(){
    if(keyPressed){
    if(keyCode == RIGHT)x += vX;
    else if(keyCode == LEFT) x -= vX;
    }
    if(x < barRadius)x = barRadius;
    if(x > width - barRadius)x = width - barRadius;
  }
  
   public void display(){
    fill(255,255,255);
    arc(x, y, twoBarRadius, twoBarRadius, PI, TWO_PI);
    line(x - barRadius , y, x + barRadius, y);
  }
}
final int BlockRow = 11;
final int BlockColumn = 30;
final int MaxBlocks = BlockRow*BlockColumn;

final float BlockGap = 6.0f;
final float BlockWidth = Width / BlockRow - BlockGap;
final float BlockHeight = (Height - barRadius)/ BlockColumn - BlockGap;
final float AreaHeight = BlockGap + BlockHeight;
final float AreaWidth = BlockGap + BlockWidth;

int moveAreaTime = 60;
float moveFlamePix = AreaHeight / moveAreaTime;
float movePix = 0;

Block[] blocks = new Block[MaxBlocks];

IntList palette;

 public void setColors(){
  palette = new IntList();
  for(int i = 0; i < 2; ++i){
    for(int j = 0; j < 2; ++j){
      for(int k = 0; k < 2; ++k){
        if(i == j && j ==k)continue;
        palette.append(color(255*i,255*j,255*k));
      }
    }
  }
}


class Block{
  float x,y,_width,_height,initX,initY;
  int paletteIndex;
  Boolean hitFlag;
  int moveFlame;
  
  Block(float tmpX, float tmpY,
  float tmpWidth,float tmpHeight, 
  int tmpPaletteIndex, Boolean tmpHitFlag){
    this.initX = tmpX;
    this.initY = tmpY;
    this._width = tmpWidth;
    this._height = tmpHeight;
    this.paletteIndex = tmpPaletteIndex;
    this.hitFlag = tmpHitFlag;
    
    this.x = this.initX;
    this.y = this.initY;
  }
  
   public void move(){
    y = initY + movePix;
  }
  
   public void display(){
    if(!hitFlag){
      fill(palette.get(paletteIndex));
      rect(x,y,_width,_height);
    }
  }
}


 public void setBlocks(){
  Boolean tmpBool;
  nowMaxBlocks = 0;
  for ( int i = 0; i < MaxBlocks; i++ ){
    if(i >= BlockRow * level * 5)tmpBool = true;
    else {
      tmpBool = false;
      nowMaxBlocks++;
    }
    
    blocks[i] = new Block(BlockGap + i % BlockRow * AreaWidth,
      BlockGap + i / BlockRow * AreaHeight,
      BlockWidth, BlockHeight, i % palette.size(), tmpBool);
      
  }
  
}
int maxBallsNum = 500;
int cntDelBlocks = 0;
int tmpIndex;

float cirLenSQ =  sq(barRadius + initBallRadius);
float cirLen =  sqrt(cirLenSQ);
float barRadiusSQ = sq(barRadius);

float tmpInitX,tmpInitY;

Boolean isReach = false;


 public Boolean gameUpdate(){
  
  bar.move();
  for(Block target : blocks)target.move();
  for(int i = 0; i < balls.size(); ++i){
    balls.get(i).move();
    if(balls.get(i).collisionWall() && balls.size() < maxBallsNum){
      balls.add(new Ball(balls.get(i).x, balls.get(i).y, 
      balls.get(i).vX - random(-1.0f,1.0f), 
      balls.get(i).vY + random(-1.0f,1.0f),
      balls.get(i).radius));
      
      
    }
    balls.get(i).collisionBar();
    tmpIndex = balls.get(i).collisionBlock();
    if(tmpIndex != -1){
      blocks[tmpIndex].hitFlag = true;
      score++;
      cntDelBlocks++;
    }
  }
  
  
  bar.display();
  for(Ball target : balls)target.display();
  for(Block target : blocks)target.display();
  
  for(int i = 0; i < balls.size(); ++i){
    if(balls.get(i).isRemove()){
      balls.remove(i);
      --i;
    }
  }
  
  flame++;
  movePix += moveFlamePix;
  if(flame == moveAreaTime){
    flame = 0;
    movePix = 0;
    
    for(int i = 0; i < BlockRow; ++i){
      if(!blocks[MaxBlocks - 1 - i].hitFlag)isReach = true;
    }
    
    for(int i = MaxBlocks - BlockRow - 1; i >= 0; --i){
      tmpIndex = i + BlockRow;
      blocks[tmpIndex].paletteIndex = blocks[i].paletteIndex;
      blocks[tmpIndex].hitFlag = blocks[i].hitFlag;
    }
    tmpIndex = blocks[0].paletteIndex;
    for(int i = 0; i < BlockRow; ++i){
      blocks[i].hitFlag = false;
      blocks[i].paletteIndex = (tmpIndex + i + 1) % palette.size();
    }
    nowMaxBlocks += BlockRow;
  }
  
  return balls.size() == 0 || 
         cntDelBlocks == nowMaxBlocks ||
         isReach ;
     
     
}


  public void settings() { size(1280, 720); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "blockBreak" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
