/* autogenerated by Processing revision 1286 on 2022-11-09 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.serial.*;
import java.util.Iterator;
import java.util.Random;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class blockBreak extends PApplet {


Serial serial;



Random r = new Random();

int nowScene = 0;

float sleepTime = 0;
final float MaxSleepTime = 50;

final int charSize = 60;

ArrayList<Ball> balls  = new ArrayList<Ball>();
ArrayList<BadBall> badBalls = new ArrayList<BadBall>();
ArrayList<BadBall> badColonys = new ArrayList<BadBall>();

int score = 0;
int nowMaxBlocks = 0;
int flame = 0;

int level = 1;
final int MaxLevel = 3;

final float Width = 1280.0f, Height = 720.0f;

final int numInData = 4;

float[] inData = new float[numInData];
float[] befInData = new float[numInData];
final int numHaveInData = 10;

final int dim = 3;

float[] devicePos = new float[dim];
float[] deviceSpd = new float[dim];


float[][] inAccs = new float[dim][];
float[][] inSpds = new float[dim][];

int endState;

 public void setup(){
  PFont font = createFont("Meiryo", 50);
  textFont(font);
  /* size commented out by preprocessor */;
  textSize(charSize);
  
  initBallX = width/2;
  initBallY = height/2;
  
  initBarX = width/2;
  initBarY = height;

  
  setColors();
  
  serial = new Serial(this, "COM3", 9600);
  
  for(int i = 0; i < dim; ++i){
    inAccs[i] = new float[numHaveInData];
    inSpds[i] = new float[numHaveInData];
  }
  
}


 public void draw(){
  background(255,255,255);
  getSerial(serial);
  switch(nowScene){
    case 0 : drawStart(); break;
    case 1 : drawGame(); break;
    case 2 : drawEnd(); break;
  }
}

 public void drawStart(){
  fill(0);
  textAlign(CENTER, CENTER);
  text("brick breaker(2210154) \n Squeeze Sponge!", width/2, height/2);
  if(inData[3] < 100 && inData[3] != 0){
    initGame();
    nowScene = 1; 
    String tmpStr = serial.readStringUntil('\n');
    tmpStr = serial.readStringUntil('\n');
    tmpStr = serial.readStringUntil('\n');
    println(tmpStr);
  }
}

int baseTime = millis();
int endTime = 0;

 public void drawGame(){
  
  fill(0);
  textAlign(LEFT, BOTTOM);
  text("time:" +
    str((millis() - baseTime)/1000)+"s:: 洗剤パワー:" + str(PApplet.parseInt(barLife)),
      0.0f,height);//"スコア:" + str(score) + 
  
  fill(255,255,255);
  
  endState = gameUpdate();
  if(endState != 0){
    
    nowScene = 2;
    balls.clear();
    badBalls.clear();
    badColonys.clear();
    cmdFlip.reset();
    cmdGrab.reset();
    wave.reset();
    sleepTime = 0;
    endTime = millis();
  }
  
}


 public void drawEnd(){
  fill(0);
  textAlign(CENTER, CENTER);
  
   switch(endState){
     case -1: text("洗剤パワーがなくなってしまった", width/2, height/2);break;
     case -2:text("諦めました...", width/2, height/2);break;
     case 1:text("ゲームクリア", width/2, height/2);break;
   }
  sleepTime += 1;

  if(sleepTime >= MaxSleepTime){
    if(inData[3] < 100 && inData[3] != 0){
      if(cntDelBlocks == nowMaxBlocks && level < MaxLevel)level += 1;
      initGame();
      nowScene = 1;
    }
  }
  
}

 public void initGame(){
  setBlocks();
  endState = 0;
  barLife = maxBarLife;
  balls.add(new Ball(initBallX, initBallY, 
  initBallVX, initBallVY, initBallRadius, MaxBallLife));
  barLife = maxBarLife;
  bar.x = initBarX;
  bar.y = initBarY;
  score = 0;
  cntDelBlocks = 0;
  baseTime = millis();
  flame = 0;
  movePix = 0;
  isReach = false;
}


float alpha = 0.2f;
float[] lowPassInData = new float[3];
float beta = 0.5f;
float[] lowPassPos = new float[3];

 public void getSerial(Serial p){
  String inString = p.readStringUntil('\n');
  
  for(int i = 0; i < numInData; ++i)befInData[i] = inData[i];
  
  if (inString != null) {  
    inData = PApplet.parseFloat(split(inString, ' ')); 
    for(int i = 0; i < numInData; ++i)if(Float.isNaN(inData[i]))inData[i] = 0;
  }else {
    for(int i = 0; i < numInData; ++i)inData[i] = befInData[i];
  }
  
  for(int i = 0; i < 3; ++i){
    lowPassInData[i] = alpha*lowPassInData[i] + (1 - alpha) * inData[i];
    inData[i] = inData[i] - lowPassInData[i]*0.3f;
  }
  
  
  for(int i = 0; i < dim; ++i){
    
    devicePos[i] -= inSpds[i][0];
    deviceSpd[i] -= inAccs[i][0];
  
    for(int j = 1; j < numHaveInData; ++j)inAccs[i][j-1] = inAccs[i][j];
    for(int j = 1; j < numHaveInData; ++j)inSpds[i][j-1] = inSpds[i][j];
 
    inAccs[i][numHaveInData - 1] = (inData[i] + befInData[i]) / numHaveInData * 100; 
    inSpds[i][numHaveInData - 1] = (inAccs[i][numHaveInData - 3] + inAccs[i][numHaveInData - 2]
    + inAccs[i][numHaveInData - 1]) / numHaveInData;
    devicePos[i] += inSpds[i][numHaveInData - 1];
    deviceSpd[i] += inAccs[i][numHaveInData - 1];
  }
  
  for(int i = 0; i < 3; ++i){
    lowPassPos[i] = beta*lowPassPos[i] + (1 - beta) * devicePos[i];
    devicePos[i] = lowPassPos[i];
    if(abs(devicePos[i]) < 0.5f)devicePos[i] = 0;
  }
  
  //println(devicePos[0],devicePos[1],devicePos[2],inData[3]);
  
}
float initBallX;
float initBallY;
float initBallVX = 0.0f;
float initBallVY = 7.0f;
float initBallRadius = 10.0f;

final int SetHitWallFlame = 10;
final int SetHitBarFlame = 5;
final float MaxBallLife = 50;

float normalVecX, normalVecY, tmpA,normSQ,norm;

class Ball{
  float x, y,vX,vY, radius;
  int hitWallFlame,hitBarFlame, hitBallFlame;
  float life;
  
  Ball(float tmpBallX,float tmpBallY,
    float tmpBallVX,float tmpBallVY, float tmpBallRadius, float tmpLife){
    this.x = tmpBallX;
    this.y = tmpBallY;
    this.vX = tmpBallVX;
    this.vY = tmpBallVY;
    this.radius = tmpBallRadius;
    this.hitWallFlame = SetHitWallFlame;
    this.hitBarFlame = SetHitBarFlame;
    this.life = tmpLife;
  }
  
   public void move(){
    x += vX;
    y += vY;
  }
  
   public Boolean collisionWall(){
    Boolean isCollision = false;
    if(hitWallFlame != 0){
      hitWallFlame--;
      return false;
    }
    
    if(x > width - this.radius || x < this.radius) {
      vX = -vX;
      hitWallFlame = SetHitWallFlame;
      isCollision = true;
    }
    if(this.y < this.radius){
      this.y =  this.radius;
      vY = -vY;;
    }
    return isCollision;
  }
  
   public Boolean collisionBar(){
    if(hitBarFlame != 0){
      hitBarFlame--;
      return false;
    }
    normalVecX = bar.x - x;
    normalVecY = bar.y - y;
    normSQ = sq(normalVecX) + sq(normalVecY);
    if(normSQ < cirLenSQ && y < bar.y && normSQ > barRadius){
      norm = sqrt(normSQ);
      normalVecX /= norm;
      normalVecY /= norm;
      tmpA = -(normalVecX*vX + normalVecY*vY)*2;
      vX = vX + tmpA*normalVecX;
      vY = vY + tmpA*normalVecY;
      hitBarFlame = SetHitBarFlame;
      
      x -= radius*normalVecX;
      y -= radius*normalVecY;
      return true;
    }
    return false;
  }
  
   public Boolean collisionBall(float oX, float oY,float oRadius){
    if(hitBallFlame != 0){
      hitBallFlame--;
      return false;
    }
    normalVecX = oX - this.x;
    normalVecY = oY - this.y;
    norm = sqrt(sq(abs(normalVecX)) + sq(abs(normalVecY)));
    //life -= 1;
    Boolean isCol = norm < (this.radius + oRadius);
    if(isCol){
      life -= 1;
      normalVecX /= norm;
      normalVecY /= norm;
      tmpA = -(normalVecX*vX + normalVecY*vY)*2;
      vX = vX + tmpA*normalVecX;
      vY = vY + tmpA*normalVecY;
      
      x -= radius*normalVecX;
      y -= radius*normalVecY;
      hitBallFlame = 5;
    }
    return isCol;
  }
  
   public void display(){
    fill(255);
    ellipse(x, y, radius*2, radius*2);
  }
  
   public Boolean isRemove(){
    return  y < 0 || y > height || life <= 0 || x < 0 || x > width;
  }
}
float initBarX = width;
float initBarY = height;
float initBarVX = 15.0f;
float initBarVY = 0.0f;
float initBarWidth = 200.0f;
float initBarHeight = 50.0f;

final float barRadius = 100.0f;
final float twoBarRadius = barRadius*2;

float barLife;
final float maxBarLife = 1000;

final float upRatio = 0.8f;
float upBarRadius = barRadius * upRatio;

Bar bar = new Bar(initBarX,initBarY, initBarVX, initBarVY, initBarWidth, initBarHeight);

Bar specialBar = new Bar(initBarX,initBarY, initBarVX, initBarVY, initBarWidth, initBarHeight);
Boolean isExistSpBar = false;

class Bar{
  float x, y, vX, vY,
      _width, _height;
  Boolean isUp = false;
  Bar(float tmpBarX, float tmpBarY, float tmpBarVX, float tmpBarVY,
      float tmpBarWidth, float tmpBarHeight){
        this.x = tmpBarX;
        this.y = tmpBarY;
        this.vX = tmpBarVX;
        this.vY = tmpBarVY;
        this._width = tmpBarWidth;
        this._height = tmpBarHeight;
  }
  
   public void move(){
    if(isUp)return;
    
    x = width/2 - devicePos[1]*100;
    
    if(x < barRadius)x = barRadius;
    if(x > width - barRadius)x = width - barRadius;
  }
  
   public void display(){
    if(isUp){
      fill(0,0,0);
      arc(x, y - upBarRadius * 0.3f, twoBarRadius * upRatio , twoBarRadius * upRatio , PI, TWO_PI);
      line(x -  upBarRadius
      , y - upBarRadius * 0.3f, x + upBarRadius, y - upBarRadius*0.3f);
    }else{
    fill(255,255,255);
    arc(x, y, twoBarRadius, twoBarRadius, PI, TWO_PI);
    line(x - barRadius , y, x + barRadius, y);
    }
  }
}
final int BlockRow = 14;
final int BlockColumn = 9;
final int MaxBlocks = BlockRow*BlockColumn;

final float BlockGap = 0f;
final float BlockWidth = Width / BlockRow - BlockGap;
final float BlockHeight = (Height - barRadius)/ BlockColumn - BlockGap;
final float AreaHeight = BlockGap + BlockHeight;
final float AreaWidth = BlockGap + BlockWidth;
float badColonyRadius = AreaHeight / 2;

final float MaxBadColonys = 10;

float validHeight = Height - twoBarRadius;

int moveAreaTime = 60;
float moveFlamePix = AreaHeight / moveAreaTime;
float movePix = 0;

IntList palette;

 public void setColors(){
  palette = new IntList();
  for(int i = 0; i < 2; ++i){
    for(int j = 0; j < 2; ++j){
      for(int k = 0; k < 2; ++k){
        if(i == j && j ==k)continue;
        palette.append(color(255*i,255*j,255*k));
      }
    }
  }
}

  
 
class BadBall extends Ball{
  int paletteIndex;
  
  BadBall(float tmpBallX,float tmpBallY,
    float tmpBallVX,float tmpBallVY, float tmpBallRadius,
    float tmpLife,int tmpPaletteIndex){
    super( tmpBallX,tmpBallY,
    tmpBallVX,tmpBallVY,tmpBallRadius, tmpLife);
    this.paletteIndex = tmpPaletteIndex;
  }
  
   public void display(){
    fill(palette.get(paletteIndex));
    ellipse(x, y, radius*2, radius*2);
  }
}



 public void setBlocks(){

  for ( int i = 0; i <  MaxBadColonys ; i++ ){
    badColonys.add(new BadBall(
    r.nextFloat() * Width,r.nextFloat() * validHeight,
    0, 0, badColonyRadius,1,
    i % palette.size()
  ));
  }
  
}
DeviceFlip cmdFlip = new DeviceFlip();
DeviceGrab cmdGrab = new DeviceGrab();

class DeviceFlip{
  int valid = -5;
  int[] ord = {0, 1, 2};
  int flipFlame = -5;
  final int[] maxPushFlame = {60, 60, 60};
  final int[] maxPullFlame = {60, 60, 60};
  final float[] pushThr = {-9,-10,-23};
  final float[] pullThr = {8,10,-12};
  final int maxValidFlame = 1;
  int  isValidFlame = maxValidFlame;
  float res;
  
  DeviceFlip(){
  }
  
   public void chk(){
    ord[0] = 0;ord[1] = 1;ord[2] = 2;
    for(int i = 0; i < dim; ++i){
      for(int j = i + 1; j < dim; ++j){
        if(abs(devicePos[i]) < abs(devicePos[j])){
          ord[i] ^= ord[j];ord[j] ^= ord[i];ord[i] ^= ord[j];
        }
      }
    }
    
    for(int i = 0; i < dim; ++i){
      int tar = ord[i];
      if(valid == -5 || (valid >> 1) == tar){
        if(flipFlame < 0){
            if(pushThr[tar] > devicePos[tar]){flipFlame = maxPushFlame[tar];valid = 0;}
            if(pullThr[tar] < devicePos[tar]){flipFlame = maxPullFlame[tar];valid = 1;}
            if(valid != -5)valid += (tar << 1);
            else continue;
            
            /*if(isValidFlame < maxValidFlame){
              if( ( (valid & 1) == 0 && (devicePos[tar] - res) <= 0) || 
              ( (valid & 1) == 1 && (devicePos[tar] - res) >= 0) ){
              }else{
                valid = -5;
                isValidFlame = maxValidFlame;
                continue;
              }
            }
            res = devicePos[tar];*/
            isValidFlame--;
        }
      }
    }
    
    if(isValidFlame == 0){
      switch(valid){
        case 0:pullX();break;
        case 1:pushX();break;
        case 2:pullY();break;
        case 3:pushY();break;
        case 4:pullZ();break;
        case 5:pushZ();break;
      }
    }
        
     
    
    if(flipFlame >= 0)--flipFlame;
    else{
      valid = -5;
      isValidFlame = maxValidFlame;
    }
  }
  
  
   public void pullX(){println(flipFlame + "pullX", devicePos[0]);

  }
  
   public void pushX(){println(flipFlame + "pushX", devicePos[0]);
    if(flipFlame > 0)isExistSpBar = true;
    else{ isExistSpBar = false;return;}
    
    if(flipFlame == maxPushFlame[0]){
      specialBar.x = bar.x;specialBar.y = bar.y;
    }else {
      specialBar.y -= Width / maxPushFlame[0];
      barLife -= (500 / maxPushFlame[0]);
    }
    
    Iterator<BadBall> itBC = badBalls.iterator();
    while(itBC.hasNext()){
    BadBall tmpBC = itBC.next();
    float oX = tmpBC.x, oY = tmpBC.y,oRadius = tmpBC.radius;
    normalVecX = abs(oX - specialBar.x);
    normalVecY = abs(oY - specialBar.y);
    normSQ = sqrt(sq(normalVecX) + sq(normalVecY));
    if(normSQ < barRadius + oRadius)itBC.remove();
    }
    
    itBC = badColonys.iterator();
    while(itBC.hasNext()){
    BadBall tmpBC = itBC.next();
    float oX = tmpBC.x, oY = tmpBC.y,oRadius = tmpBC.radius;
    normalVecX = abs(oX - specialBar.x);
    normalVecY = abs(oY - specialBar.y);
    normSQ = sqrt(sq(normalVecX) + sq(normalVecY));
    if(normSQ < barRadius + oRadius)itBC.remove();
    }
  
    specialBar.display();
  }
   public void pullY(){println(flipFlame + "pullY", devicePos[1]);}
   public void pushY(){println(flipFlame + "pushY", devicePos[1]);}
  
   public void pushZ(){println(flipFlame + "pullZ", devicePos[2]);
  barLife += 3;
  }
  
   public void pullZ(){println(flipFlame + "pushZ", devicePos[2]);
  bar.isUp = true;
  if(flipFlame == 0)bar.isUp = false;
  }
  
   public void reset(){
    valid = -5;
    flipFlame = -5;
    isValidFlame = maxValidFlame;
  }
}


class DeviceGrab{
  final int maxGrabFlame = 60;
  int grabFlame = 0;
  float maxGrabPower = 0;
  float resGrabPower = 0;
  float maxCreatBall = 15;
  float numCreatBall = 0;
  Boolean isBefCreat = false;
  DeviceGrab(){}
  
   public void chk(){
    if(grabFlame < 0){
      if(inData[3] < 100){
        maxGrabPower = inData[3];
        resGrabPower = maxGrabPower;
        grabFlame = maxGrabFlame;
        numCreatBall = 0;
      }else return;
    }
    
    grab();
    if(grabFlame >= 0)--grabFlame;
  }
  
   public void grab(){
    println(grabFlame + "grab",inData[3] );
    if(resGrabPower >= inData[3] && numCreatBall < maxCreatBall && !isBefCreat){
      float ang = r.nextFloat()*PI;
      float cos_ = cos(ang);
      float sin_ = sin(ang);
      
      balls.add(new Ball(bar.x - cos_ * cirLen, bar.y - sin_ * cirLen, 
      3 * cos_, 3 * sin_,
      initBallRadius, MaxBallLife / 2));
      barLife -= 5;
      ++numCreatBall;
      isBefCreat = true;
    }else isBefCreat = false;
    resGrabPower = inData[3];
  }
  
   public void reset(){
    grabFlame = 0;
    maxGrabPower = 0;
    resGrabPower = 0;
    maxCreatBall = 15;
    numCreatBall = 0;
    isBefCreat = false;
  }
}
Wave wave = new Wave(); 



class Wave{
  final int maxIntervalFlame = 300;
  final int maxWashFlame = 360;
  int waveFlame = 0;
  float bottomY = 0;
  float topY = 0;
  float speedY = Height * 2 / (maxWashFlame - maxIntervalFlame);
  
  Wave(){
    waveFlame = 0;
  };
  
   public void wash(){
    ++waveFlame;
    if(waveFlame > maxIntervalFlame){
      if(waveFlame > maxWashFlame){
        waveFlame = 0;
        return;
      }
      bottomY = speedY*(waveFlame - maxIntervalFlame);
      topY = bottomY - Height;
      
      if(bottomY > bar.y - barRadius && !bar.isUp)barLife -= 5;
      
      for(int i = 0; i < badBalls.size(); ++i){
        float tmpY = badBalls.get(i).y;
        if(bottomY > tmpY && tmpY > topY){
          badBalls.get(i).y += speedY;
          --i;
        }
      }
      
      for(int i = 0; i < balls.size(); ++i){
        float tmpY = balls.get(i).y;
        if(bottomY > tmpY && tmpY > topY){
          balls.get(i).y += speedY;
          --i;
        }
      }
      
    }
  }
  
   public void display(){
    if(waveFlame > maxIntervalFlame){
    fill(84,192,245, 100);
    rect(0, topY, width,height);
    }
  }
  
   public void reset(){
    waveFlame = 0;
  }
  
}
int maxBallsNum = 500;
int maxFlame = 300;
int cntDelBlocks = 0;
int tmpIndex;

float cirLenSQ =  sq(barRadius + initBallRadius);
float cirLen =  sqrt(cirLenSQ);
float barRadiusSQ = sq(barRadius);

float tmpInitX,tmpInitY;

Boolean isReach = false;




 public int gameUpdate(){
  flame++;
  flame %= maxFlame;
  
  cmdFlip.chk();
  cmdGrab.chk();
  
  bar.move();
  for(int i = 0; i < balls.size(); ++i){
    balls.get(i).move();
    balls.get(i).collisionWall();
    
    if(!bar.isUp)balls.get(i).collisionBar();
   
   for(int j = 0; j < badColonys.size(); ++j){
      if(balls.get(i).collisionBall(badColonys.get(j).x, badColonys.get(j).y, badColonys.get(j).radius)){
        badColonys.remove(j);
        //existBall = false;
        break;
      }
    }
    
    for(int j = 0; j < badBalls.size(); ++j){
      if(balls.get(i).life > 0){ 
        if(balls.get(i).collisionBall(badBalls.get(j).x, badBalls.get(j).y, badBalls.get(j).radius)){
          badBalls.remove(j);
        }
      }
    }
    
    if(balls.get(i).life < 0){
      balls.remove(i);
      --i;
    }
  }
  
  Iterator<BadBall> itBC = badBalls.iterator();
  while(itBC.hasNext()){
    BadBall tmpBC = itBC.next();
    tmpBC.move();
    if(bar.isUp)continue;
    if(tmpBC.collisionBar()){
      barLife -= 10;
      itBC.remove();
    }
  }
  
  
  wave.wash();
  
  

  for(BadBall target : badColonys){
    if(r.nextFloat() < 0.03f){
      float ang = r.nextFloat()*TWO_PI;
      float cos_ = cos(ang);
      float sin_ = sin(ang);
      badBalls.add(new BadBall(
      target.x + target.radius * cos_ , target.y +  target.radius * sin_,
      3*cos_ - 0.01f, 3*sin_ + 0.01f, badColonyRadius / 2, 1,
      target.paletteIndex
      ));
    }
  }
  
  
  
  bar.display();
  for(BadBall target : badColonys)target.display();
  for(BadBall target : badBalls)target.display();
  for(Ball target : balls)target.display();
  
  for(int i = 0; i < balls.size(); ++i){
    if(balls.get(i).isRemove()){
      balls.remove(i);
      --i;
    }
  }
  
  for(int i = 0; i < badBalls.size(); ++i){
    if(badBalls.get(i).isRemove()){
      badBalls.remove(i);
      --i;
    }
  }
  
  wave.display();
  
  
  movePix += moveFlamePix;
  
  if(barLife < 0)return -1;
  if(badColonys.size() == 0)return 1;
  if(cmdFlip.valid == 0 && cmdFlip.isValidFlame == 0)return -2;
  
  return 0;
     
     
}


  public void settings() { size(1280, 720); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "blockBreak" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
